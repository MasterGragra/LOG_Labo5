@startuml
'Architecture MVC avec patrons de conception
title Diagramme de classe

skinparam linetype ortho
skinparam nodesep 80
skinparam ranksep 100
skinparam shadowing false

package "modele" #E8F5E9 {
  class Image implements Subject {
    -chemin: String
    -imageJavaFX: javafx.scene.image.Image
    -observers: List<Observer>
    +chargerImage(chemin : String)
    +getJavaFXImage(): javafx.scene.image.Image
    +attach(observer: Observer)
    +detach(observer: Observer)
    +notifyObservers()
  }
  note left of Image
    Représente l'image originale
    Sujet dans le pattern Observer
  endnote

  class Perspective implements Subject, Serializable {
    -facteurEchelle: DoubleProperty
    -positionX: IntegerProperty
    -positionY: IntegerProperty
    -image: Image
    -observers: List<Observer>
    +Perspective(image: Image)
    +createMemento(): PerspectiveMemento
    +setMemento(memento: PerspectiveMemento)
    +setFacteurEchelle(facteur: double)
    +setPosition(x: int, y: int)
    +getImage(): Image
    +getFacteurEchelle(): double
    +getPositionX(): int
    +getPositionY(): int
    +facteurEchelleProperty(): DoubleProperty
    +positionXProperty(): IntegerProperty
    +positionYProperty(): IntegerProperty
    +attach(observer: Observer)
    +detach(observer: Observer)
    +notifyObservers()
  }
  note left of Perspective
    Contient les paramètres d'affichage de l'image
    Sérialisable pour la persistance
    Utilise Memento pour sauvegarder son état
  endnote

  interface Subject {
    +attach(observer: Observer)
    +detach(observer: Observer)
    +notifyObservers()
  }
  note right of Subject
    Pattern Observer: notifie les observateurs
    lors des changements dans le modèle
  endnote
}

package "vue" #E3F2FD {
  interface Observer {
    +update(parameter: Subject)
  }
  note left of Observer
    Interface du pattern Observer
    permettant aux vues de recevoir
    les notifications du modèle
  endnote

  abstract class VueAbstraite implements Observer {
    #perspective: Perspective
    #pane: Pane
    +VueAbstraite(perspective: Perspective)
    +update(subject: Subject)
    #abstract dessiner()
    +getPane(): Pane
    +renduInitial()
  }

  class VueFixe extends VueAbstraite {
    -imageView: ImageView
    +VueFixe(perspective: Perspective)
    #dessiner()
    +getImageView(): ImageView
  }

  abstract class VueInteractive extends VueAbstraite {
    #controleSouris: ControleSouris
    +VueInteractive(perspective: Perspective)
    #activerClipping()
    +setControleSouris(controle: ControleSouris)
    +getControleSouris(): ControleSouris
  }

  class VuePrincipale extends VueInteractive {
    -imageView: ImageView
    +VuePrincipale(perspective: Perspective)
    #dessiner()
    +getImageView(): ImageView
}

  class VueSecondaire extends VueInteractive {
    -imageView: ImageView
    +VueSecondaire(perspective: Perspective)
    #dessiner()
    +getImageView(): ImageView
  }
  note left of VueSecondaire
    Les vues sont des observateurs
    qui se mettent à jour automatiquement
    lorsque le modèle change
  endnote
}

package "controleur" #FFF3E0 {
  interface ControleSouris {
    +gererMousePressed(evt: MouseEvent)
    +gererMouseDragged(evt: MouseEvent)
    +gererMouseReleased(evt: MouseEvent)
  }
  note right of ControleSouris
    Pattern Strategy: permet de changer
    dynamiquement le comportement
    des vues face aux événements souris
  endnote

  class ControleZoom {
    -perspective: Perspective
    -commandManager: CommandManager
    -facteurZoomInitial: double
    -positionXInitiale: double
    -positionYInitiale: double
    +ControleZoom(perspective: Perspective)
    +gererMousePressed(evt: MouseEvent)
    +gererMouseDragged(evt: MouseEvent)
    +gererMouseReleased(evt: MouseEvent)
    +effectuerZoom(deltaY: double)
}

  class ControleTranslation {
    -perspective: Perspective
    -commandManager: CommandManager
    -sourisXInitiale: double
    -sourisYInitiale: double
    -perspectiveXInitiale: int
    -perspectiveYInitiale: int
    +ControleTranslation(perspective: Perspective)
    +gererMousePressed(evt: MouseEvent)
    +gererMouseDragged(evt: MouseEvent)
    +gererMouseReleased(evt: MouseEvent)
  }

  class ImageController {
    -perspectives: List<Perspective>
    -imageViews: List<ImageView>
    -panes: List<StackPane>
    -strategies: Map<StackPane, ControleSouris>
    -controleZooms: Map<StackPane, ControleZoom>
    -commandManager: CommandManager
    +configurerEvenementsSouris(pane: StackPane, perspective: Perspective, vue: VueInteractive)
    +lierPerspectiveEtVue(perspective: Perspective, imageView: ImageView, vue: VueInteractive)
  }
  note bottom of ImageController
    Contrôleur responsable de
    lier les vues JavaFX aux perspectives
    et configurer les interactions utilisateur
  endnote
}

package "commande" #F3E5F5 {
  interface Command {
    +execute()
    +undo()
  }
  note right of Command
    Pattern Command: encapsule une action
    dans un objet pour pouvoir l'exécuter
    ou l'annuler ultérieurement
  endnote

  class ZoomCommand implements Command {
    -perspective: Perspective
    -ancienFacteur: double
    -nouveauFacteur: double
    +ZoomCommand(perspective: Perspective, nouveauFacteur: double)
    +setFacteurInitial(facteurInitial: double)
    +execute()
    +undo()
  }

  class TranslationCommand implements Command {
    -perspective: Perspective
    -ancienX: int
    -ancienY: int
    -nouveauX: int
    -nouveauY: int
    +TranslationCommand(perspective: Perspective, nouveauX: int, nouveauY: int)
    +setPositionInitiale(initialX: int, initialY: int)
    +execute()
    +undo()
  }

  class CommandManager << Singleton >> {
    -static instance: CommandManager
    -commandesExecutees: Stack<Command>
    -commandesAnnulees: Stack<Command>
    -static TAILLE_MAX_HISTORIQUE: int
    -canUndoProperty: ReadOnlyBooleanWrapper
    -canRedoProperty: ReadOnlyBooleanWrapper
    -CommandManager()
    +static getInstance(): CommandManager
    +executeCommand(command: Command)
    +undo()
    +redo()
    +clearRedoStack()
    +canUndo(): boolean
    +canRedo(): boolean
    +canUndoProperty(): ReadOnlyBooleanProperty
    +canRedoProperty(): ReadOnlyBooleanProperty
    -updateProperties()
    +getUndoStackSize(): int
    +getRedoStackSize(): int
  }
  note right of CommandManager
    Pattern Singleton: assure une instance unique
    Gère l'historique des commandes
    et permet d'annuler les opérations
  endnote
}

package "memento" #FFEBEE {
  class PerspectiveMemento implements Serializable {
    -facteurEchelle: double
    -positionX: int
    -positionY: int
    +PerspectiveMemento(facteur: double, x: int, y: int)
    +getFacteurEchelle(): double
    +getPositionX(): int
    +getPositionY(): int
  }
  note right of PerspectiveMemento
    Pattern Memento: capture l'état interne
    d'une perspective pour restauration future
  endnote

  class Sauvegarde {
    +sauvegarderEtat(perspectives: List<Perspective>, fichier: String)
    +chargerEtat(fichier: String): List<Perspective>
    +fichierExiste(fichier: String): boolean
  }
  note right of Sauvegarde
    Utilise la sérialisation Java pour
    sauvegarder/charger les perspectives
  endnote
}

package "application" #E0F7FA {
  class ApplicationMain extends Application {
    -controller: ApplicationController
    -gestionnaireInterface: GestionnaireInterface
    +main(args: String[])
    +start(primaryStage: Stage)
    +stop()
  }
  note left of ApplicationMain
    Point d'entrée JavaFX
    Gère la configuration initiale de l'interface et le cycle de vie de l'application
  endnote

  class ApplicationController {
      -perspectives: List<Perspective>
      -vues: Map<String, VueAbstraite>
      -imageController: ImageController
      -sauvegarde: Sauvegarde
      +initialiserModeles()
      +initialiserVues()
      +creerInterface(): Parent
      +chargerImage(cheminImage: String)
      +getPerspectives(): List<Perspective>
      +getVues(): Map<String, VueAbstraite>
  }
  note left of ApplicationController
    Contrôleur principal de l'application
    Coordonne les modèles, vues et contrôleurs
  endnote

  class GestionnaireInterface {
    -stage: Stage
    -scene: Scene
    +creerFenetre(titre: String): Stage
    +creerMenu(root: Parent): MenuBar
    +ajouterVue(conteneur: Pane, vue: VueAbstraite)
    +configurerRaccourcisClavier(scene: Scene)
  }
  note right of GestionnaireInterface
    Gestion de l'interface utilisateur
    Création des fenêtres, menus, etc.
  endnote
}

' Relations
Subject "1" -- "0..*" Observer : observe >
Image "1" *-- "0..*" Perspective
Perspective -- PerspectiveMemento : crée >
VueAbstraite -- Perspective : observe >
VueInteractive -- ControleSouris : utilise >

' Relations de contrôleur
ControleSouris <|.. ControleZoom
ControleSouris <|.. ControleTranslation
CommandManager "1" -- "*" Command : gère >
ControleZoom -- CommandManager : utilise >
ControleTranslation -- CommandManager : utilise >
Perspective -- ImageController : manipule >

' Relations d'application
ApplicationController -- Sauvegarde : utilise >
ApplicationController "1" o-- "*" Perspective
ApplicationController "1" -- "1" ImageController : utilise >
ApplicationController "1" o-- "*" VueAbstraite : gère >
ApplicationMain -- ApplicationController : utilise >
ApplicationMain -- GestionnaireInterface : utilise >

note as N1
Architecture MVC avec JavaFX:
- Modèle: Image, Perspective
- Vue: VueAbstraite et ses sous-classes
- Contrôleur: ImageController, ControleZoom, ControleTranslation
end note

note as N2
Patrons de conception utilisés:
- Observer: Subject/Observer pour MVC
- Command: Pour undo/redo
- Strategy: ControleSouris pour comportements
- Memento: PerspectiveMemento pour sauvegarde d'état
- Singleton: CommandManager comme gestionnaire unique
end note

N1 -[hidden]-> N2
N2 -[hidden]-> vue
@enduml